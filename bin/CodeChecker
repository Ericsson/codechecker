#!/usr/bin/env python3
# -------------------------------------------------------------------------
#
#  Part of the CodeChecker project, under the Apache License v2.0 with
#  LLVM Exceptions. See LICENSE for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# -------------------------------------------------------------------------
"""
Used to kickstart CodeChecker.

Saves original environment without modifications.
Used to run the logging in the same env.
PYTHON_ARGCOMPLETE_OK
"""
# This is for enabling CodeChecker as a filename (i.e. module name).
# pylint: disable=invalid-name
# pylint: enable=invalid-name

import os
import pickle
import shutil
import signal
import subprocess
import sys
import tempfile

PROC_PID = None
EXIT_CODE = None


def run_codechecker_in_process(subcommand=None) -> int:
    package_bin = os.path.dirname(os.path.realpath(__file__))
    package_root = os.path.dirname(package_bin)
    for path in (os.path.join(package_root, 'lib', 'python3'), package_root):
        if os.path.isdir(path) and path not in sys.path:
            sys.path.insert(0, path)

    os.environ.setdefault('CC_BIN_DIR', package_bin)

    forwarded_argv = [sys.argv[0]]
    if subcommand:
        forwarded_argv.append(subcommand)
    forwarded_argv.extend(sys.argv[1:])
    sys.argv = forwarded_argv

    from codechecker_common import cli
    return cli.main() or 0


def run_codechecker(checker_env, subcommand=None) -> int:
    """
    Run the CodeChecker.
        * checker_env - CodeChecker will be run in the checker env.
        * subcommand - CodeChecker will run the given subcommand by default,
                       if specified. If not, the main script will run and parse
                       all the commands.
    """
    package_bin = os.path.dirname(os.path.realpath(__file__))
    package_root = os.path.dirname(package_bin)
    lib_dir_path = os.path.join(package_root, 'lib', 'python3')

    checker_env['PYTHONPATH'] = lib_dir_path
    checker_env['CC_BIN_DIR'] = package_bin

    codechecker_main = \
        os.path.join(lib_dir_path, 'codechecker_common', 'cli.py')

    checker_cmd = [sys.executable, codechecker_main]

    if subcommand:
        # If a subcommand is specified (script is executed from a
        # wrapper entry point, add it to the command list).
        # E.g. 'codechecker-log ...' is the same as 'CodeChecker log ...'.
        checker_cmd.append(subcommand)

    checker_cmd.extend(sys.argv[1:])

    proc = subprocess.Popen(checker_cmd,
                            encoding="utf=8",
                            errors="ignore",
                            env=checker_env)
    global PROC_PID
    PROC_PID = proc.pid

    global EXIT_CODE
    EXIT_CODE = proc.wait()

    return EXIT_CODE


def main(subcommand=None) -> int:
    original_env = os.environ.copy()
    checker_env = original_env

    if '_ARGCOMPLETE' in os.environ:
        return run_codechecker_in_process(subcommand)

    tmp_dir = tempfile.mkdtemp()

    original_env_file = os.path.join(tmp_dir, 'original_env.pickle')

    def _remove_tmp():
        # Remove temporary directory.
        try:
            shutil.rmtree(tmp_dir)
        except Exception as ex:
            if not isinstance(ex, OSError):
                print('Failed to remove temporary directory: ' + tmp_dir)
                print('Manual cleanup is required.')
                print(ex)

    try:
        with open(original_env_file, 'wb') as env_save:
            pickle.dump(original_env, env_save)

        checker_env['CODECHECKER_ORIGINAL_BUILD_ENV'] = original_env_file
    except Exception as ex:
        print('Saving original build environment failed.')
        print(ex)

    def signal_handler(signum, _frame):
        """
        Forwards the received signal to the CodeChecker subprocess started by
        this `main` script.
        """
        global PROC_PID
        if PROC_PID and sys.platform != "win32":
            try:
                os.kill(PROC_PID, signum)
            except ProcessLookupError:
                pass

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    if sys.platform != "win32":
        signal.signal(signal.SIGHUP, signal_handler)
        signal.signal(signal.SIGCHLD, signal_handler)

    try:
        global EXIT_CODE
        EXIT_CODE = run_codechecker(checker_env, subcommand)
    finally:
        _remove_tmp()

    return EXIT_CODE


if __name__ == "__main__":
    sys.exit(main(None) or 0)
